// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BoardType string

const (
	BoardTypeACE       BoardType = "ACE"
	BoardTypeCURIOSITY BoardType = "CURIOSITY"
	BoardTypeSOPHIE    BoardType = "SOPHIE"
	BoardTypeGRAIL     BoardType = "GRAIL"
	BoardTypeMERCURY   BoardType = "MERCURY"
)

func (e *BoardType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BoardType(s)
	case string:
		*e = BoardType(s)
	default:
		return fmt.Errorf("unsupported scan type for BoardType: %T", src)
	}
	return nil
}

type NullBoardType struct {
	BoardType BoardType `json:"board_type"`
	Valid     bool      `json:"valid"` // Valid is true if BoardType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBoardType) Scan(value interface{}) error {
	if value == nil {
		ns.BoardType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BoardType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBoardType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BoardType), nil
}

type EloType string

const (
	EloTypeBlitz   EloType = "blitz"
	EloTypeBullet  EloType = "bullet"
	EloTypeRapid   EloType = "rapid"
	EloTypeClassic EloType = "classic"
)

func (e *EloType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EloType(s)
	case string:
		*e = EloType(s)
	default:
		return fmt.Errorf("unsupported scan type for EloType: %T", src)
	}
	return nil
}

type NullEloType struct {
	EloType EloType `json:"elo_type"`
	Valid   bool    `json:"valid"` // Valid is true if EloType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEloType) Scan(value interface{}) error {
	if value == nil {
		ns.EloType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EloType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEloType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EloType), nil
}

type ItemType string

const (
	ItemTypeBoardSkin ItemType = "board_skin"
	ItemTypePieceSkin ItemType = "piece_skin"
)

func (e *ItemType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemType(s)
	case string:
		*e = ItemType(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemType: %T", src)
	}
	return nil
}

type NullItemType struct {
	ItemType ItemType `json:"item_type"`
	Valid    bool     `json:"valid"` // Valid is true if ItemType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemType) Scan(value interface{}) error {
	if value == nil {
		ns.ItemType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemType), nil
}

type MatchType string

const (
	MatchTypeRANKED   MatchType = "RANKED"
	MatchTypeFRIENDLY MatchType = "FRIENDLY"
	MatchTypePRIVATE  MatchType = "PRIVATE"
	MatchTypeBOTS     MatchType = "BOTS"
)

func (e *MatchType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MatchType(s)
	case string:
		*e = MatchType(s)
	default:
		return fmt.Errorf("unsupported scan type for MatchType: %T", src)
	}
	return nil
}

type NullMatchType struct {
	MatchType MatchType `json:"match_type"`
	Valid     bool      `json:"valid"` // Valid is true if MatchType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMatchType) Scan(value interface{}) error {
	if value == nil {
		ns.MatchType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MatchType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMatchType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MatchType), nil
}

type Termination string

const (
	TerminationOUTOFTIME  Termination = "OUT_OF_TIME"
	TerminationSURRENDER  Termination = "SURRENDER"
	TerminationLASER      Termination = "LASER"
	TerminationUNFINISHED Termination = "UNFINISHED"
)

func (e *Termination) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Termination(s)
	case string:
		*e = Termination(s)
	default:
		return fmt.Errorf("unsupported scan type for Termination: %T", src)
	}
	return nil
}

type NullTermination struct {
	Termination Termination `json:"termination"`
	Valid       bool        `json:"valid"` // Valid is true if Termination is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTermination) Scan(value interface{}) error {
	if value == nil {
		ns.Termination, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Termination.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTermination) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Termination), nil
}

type Winner string

const (
	WinnerP1WINS Winner = "P1_WINS"
	WinnerP2WINS Winner = "P2_WINS"
	WinnerDRAW   Winner = "DRAW"
	WinnerNONE   Winner = "NONE"
)

func (e *Winner) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Winner(s)
	case string:
		*e = Winner(s)
	default:
		return fmt.Errorf("unsupported scan type for Winner: %T", src)
	}
	return nil
}

type NullWinner struct {
	Winner Winner `json:"winner"`
	Valid  bool   `json:"valid"` // Valid is true if Winner is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWinner) Scan(value interface{}) error {
	if value == nil {
		ns.Winner, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Winner.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWinner) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Winner), nil
}

type Account struct {
	AccountID    int64  `json:"account_id"`
	Mail         string `json:"mail"`
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
	IsDeleted    bool   `json:"is_deleted"`
	Level        int32  `json:"level"`
	Xp           int32  `json:"xp"`
	Money        int32  `json:"money"`
	BoardSkin    int32  `json:"board_skin"`
	PieceSkin    int32  `json:"piece_skin"`
}

type Friendship struct {
	User1ID   int64 `json:"user1_id"`
	User2ID   int64 `json:"user2_id"`
	Accepted1 bool  `json:"accepted_1"`
	Accepted2 bool  `json:"accepted_2"`
}

type ItemOwner struct {
	UserID int64 `json:"user_id"`
	ItemID int32 `json:"item_id"`
}

type Match struct {
	MatchID         int64              `json:"match_id"`
	P1ID            int64              `json:"p1_id"`
	P2ID            int64              `json:"p2_id"`
	P1Elo           int32              `json:"p1_elo"`
	P2Elo           int32              `json:"p2_elo"`
	Date            pgtype.Timestamptz `json:"date"`
	Winner          Winner             `json:"winner"`
	Termination     Termination        `json:"termination"`
	MatchType       MatchType          `json:"match_type"`
	Board           BoardType          `json:"board"`
	MovementHistory string             `json:"movement_history"`
	TimeBase        int32              `json:"time_base"`
	TimeIncrement   int32              `json:"time_increment"`
}

type Rating struct {
	UserID  int64   `json:"user_id"`
	EloType EloType `json:"elo_type"`
	Value   int32   `json:"value"`
}

type RefreshSession struct {
	SessionID int64              `json:"session_id"`
	AccountID int64              `json:"account_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type ShopItem struct {
	ItemID         int32    `json:"item_id"`
	Price          int32    `json:"price"`
	LevelRequisite int32    `json:"level_requisite"`
	ItemType       ItemType `json:"item_type"`
	IsDefault      bool     `json:"is_default"`
}
