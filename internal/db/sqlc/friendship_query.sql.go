// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: friendship_query.sql

package db

import (
	"context"
)

const createFriendship = `-- name: CreateFriendship :one
INSERT INTO friendship (
    user1_id, user2_id, accepted_1, accepted_2)
VALUES (
    $1, $2, $3, $4
)
RETURNING user1_id, user2_id, accepted_1, accepted_2
`

type CreateFriendshipParams struct {
	User1ID   int64 `json:"user1_id"`
	User2ID   int64 `json:"user2_id"`
	Accepted1 bool  `json:"accepted_1"`
	Accepted2 bool  `json:"accepted_2"`
}

func (q *Queries) CreateFriendship(ctx context.Context, arg CreateFriendshipParams) (Friendship, error) {
	row := q.db.QueryRow(ctx, createFriendship,
		arg.User1ID,
		arg.User2ID,
		arg.Accepted1,
		arg.Accepted2,
	)
	var i Friendship
	err := row.Scan(
		&i.User1ID,
		&i.User2ID,
		&i.Accepted1,
		&i.Accepted2,
	)
	return i, err
}

const deleteFriendship = `-- name: DeleteFriendship :exec
DELETE FROM friendship 
WHERE ($1 = user1_id AND $2 = user2_id) OR ($1 = user2_id AND $2 = user1_id)
`

type DeleteFriendshipParams struct {
	User1ID int64 `json:"user1_id"`
	User2ID int64 `json:"user2_id"`
}

func (q *Queries) DeleteFriendship(ctx context.Context, arg DeleteFriendshipParams) error {
	_, err := q.db.Exec(ctx, deleteFriendship, arg.User1ID, arg.User2ID)
	return err
}

const getFriendship = `-- name: GetFriendship :one
SELECT user1_id, user2_id, accepted_1, accepted_2 FROM friendship 
WHERE ($1 = user1_id AND $2 = user2_id) OR ($1 = user2_id AND $2 = user1_id)
`

type GetFriendshipParams struct {
	User1ID int64 `json:"user1_id"`
	User2ID int64 `json:"user2_id"`
}

func (q *Queries) GetFriendship(ctx context.Context, arg GetFriendshipParams) (Friendship, error) {
	row := q.db.QueryRow(ctx, getFriendship, arg.User1ID, arg.User2ID)
	var i Friendship
	err := row.Scan(
		&i.User1ID,
		&i.User2ID,
		&i.Accepted1,
		&i.Accepted2,
	)
	return i, err
}

const getUserFriendships = `-- name: GetUserFriendships :many
SELECT friendship.user2_id AS user_id, account.username, account.level, account.xp 
FROM friendship 
JOIN account ON friendship.user2_id = account.account_id
WHERE accepted_1 = TRUE AND accepted_2 = TRUE AND $1 = friendship.user1_id

UNION

SELECT friendship.user1_id AS user_id, account.username, account.level, account.xp 
FROM friendship 
JOIN account ON friendship.user1_id = account.account_id
WHERE accepted_1 = TRUE AND accepted_2 = TRUE AND $1 = friendship.user2_id
`

type GetUserFriendshipsRow struct {
	UserID   int64  `json:"user_id"`
	Username string `json:"username"`
	Level    int32  `json:"level"`
	Xp       int32  `json:"xp"`
}

func (q *Queries) GetUserFriendships(ctx context.Context, user1ID int64) ([]GetUserFriendshipsRow, error) {
	rows, err := q.db.Query(ctx, getUserFriendships, user1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserFriendshipsRow
	for rows.Next() {
		var i GetUserFriendshipsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Level,
			&i.Xp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPendingRecievedFriendships = `-- name: GetUserPendingRecievedFriendships :many
SELECT friendship.user2_id AS user_id, account.username, account.level, account.xp 
FROM friendship 
JOIN account ON friendship.user2_id = account.account_id
WHERE accepted_1 = FALSE AND accepted_2 = TRUE AND $1 = friendship.user1_id

UNION

SELECT friendship.user1_id AS user_id, account.username, account.level, account.xp 
FROM friendship 
JOIN account ON friendship.user1_id = account.account_id
WHERE accepted_1 = TRUE AND accepted_2 = FALSE AND $1 = friendship.user2_id
`

type GetUserPendingRecievedFriendshipsRow struct {
	UserID   int64  `json:"user_id"`
	Username string `json:"username"`
	Level    int32  `json:"level"`
	Xp       int32  `json:"xp"`
}

func (q *Queries) GetUserPendingRecievedFriendships(ctx context.Context, user1ID int64) ([]GetUserPendingRecievedFriendshipsRow, error) {
	rows, err := q.db.Query(ctx, getUserPendingRecievedFriendships, user1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPendingRecievedFriendshipsRow
	for rows.Next() {
		var i GetUserPendingRecievedFriendshipsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Level,
			&i.Xp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPendingSentFriendships = `-- name: GetUserPendingSentFriendships :many
SELECT friendship.user2_id AS user_id, account.username, account.level, account.xp 
FROM friendship 
JOIN account ON friendship.user2_id = account.account_id
WHERE accepted_1 = TRUE AND accepted_2 = FALSE AND $1 = friendship.user1_id

UNION

SELECT friendship.user1_id AS user_id, account.username, account.level, account.xp 
FROM friendship 
JOIN account ON friendship.user1_id = account.account_id
WHERE accepted_1 = FALSE AND accepted_2 = TRUE AND $1 = friendship.user2_id
`

type GetUserPendingSentFriendshipsRow struct {
	UserID   int64  `json:"user_id"`
	Username string `json:"username"`
	Level    int32  `json:"level"`
	Xp       int32  `json:"xp"`
}

func (q *Queries) GetUserPendingSentFriendships(ctx context.Context, user1ID int64) ([]GetUserPendingSentFriendshipsRow, error) {
	rows, err := q.db.Query(ctx, getUserPendingSentFriendships, user1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPendingSentFriendshipsRow
	for rows.Next() {
		var i GetUserPendingSentFriendshipsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Level,
			&i.Xp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setFriendship = `-- name: SetFriendship :exec
UPDATE friendship
SET accepted_1 = TRUE, accepted_2 = TRUE
WHERE ($1 = user1_id AND $2 = user2_id) OR ($2 = user2_id AND $1 = user1_id)
`

type SetFriendshipParams struct {
	User1ID int64 `json:"user1_id"`
	User2ID int64 `json:"user2_id"`
}

func (q *Queries) SetFriendship(ctx context.Context, arg SetFriendshipParams) error {
	_, err := q.db.Exec(ctx, setFriendship, arg.User1ID, arg.User2ID)
	return err
}
